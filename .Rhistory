theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
# Convert to long format
plot_df <- pivot_longer(BH_summary, cols = c(BH_Return, Tangency_Expected),
names_to = "Strategy", values_to = "Value")
# Plot with custom legend labels
ggplot(plot_df, aes(x = Window, y = Value, color = Strategy)) +
geom_line(linewidth = 0.9) +
geom_point(size = 1.5) +
labs(
title = "Buy-and-Hold vs Tangency Portfolio Expected Return",
x = "Test Window", y = "Cumulative Return",
color = "Portfolio Strategy"
) +
scale_color_manual(
values = c("BH_Return" = "red", "Tangency_Expected" = "blue"),
labels = c("BH_Return" = "Buy-and-Hold", "Tangency_Expected" = "Tangency Portfolio Expected")
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
knitr::kable(summary_df, digits=6, caption="In-sample vs Out-of-sample Portfolio Statistics")
# -----------------------------
# 0) Clear environment and load libraries
# -----------------------------
rm(list = ls())
# Required libraries
library(openxlsx)     # Excel data
library(timeSeries)   # timeSeries object handling
library(xts)          # time series manipulation
library(zoo)          # time series utilities
library(matrixStats)  # colSds
library(quadprog)     # optimization
library(knitr)        # tables
library(dplyr)        # data wrangling
library(ggplot2)      # plotting
library(tidyr)        # data reshaping
# -----------------------------
# 1) Load raw Excel data
# -----------------------------
# Read all 4 sheets into a list
dfS <- list()
for (i in 1:4) {
dfS[[i]] <- read.xlsx("00_raw_data/PT-TAA-JSE-Daily-1994-2017.xlsx", sheet = i, detectDates = TRUE)
cat("Sheet", i, "loaded with dimensions:", dim(dfS[[i]]), "\n")
}
# -----------------------------
# 0) Clear environment and load libraries
# -----------------------------
rm(list = ls())
# Required libraries
library(openxlsx)     # Excel data
library(timeSeries)   # timeSeries object handling
library(xts)          # time series manipulation
library(zoo)          # time series utilities
library(matrixStats)  # colSds
library(quadprog)     # optimization
library(knitr)        # tables
library(dplyr)        # data wrangling
library(ggplot2)      # plotting
library(tidyr)        # data reshaping
# -----------------------------
# 1) Load raw Excel data
# -----------------------------
# Read all 4 sheets into a list
dfS <- list()
for (i in 1:4) {
dfS[[i]] <- read.xlsx("00_raw_data/PT-TAA-JSE-Daily-1994-2017.xlsx", sheet = i, detectDates = TRUE)
cat("Sheet", i, "loaded with dimensions:", dim(dfS[[i]]), "\n")
}
# -----------------------------
# 0) Clear environment and load libraries
# -----------------------------
rm(list = ls())
# Required libraries
library(openxlsx)     # Excel data
library(timeSeries)   # timeSeries object handling
library(xts)          # time series manipulation
library(zoo)          # time series utilities
library(matrixStats)  # colSds
library(quadprog)     # optimization
library(knitr)        # tables
library(dplyr)        # data wrangling
library(ggplot2)      # plotting
library(tidyr)        # data reshaping
# -----------------------------
# 1) Load raw Excel data
# -----------------------------
# Read all 4 sheets into a list
dfS <- list()
for (i in 1:4) {
dfS[[i]] <- read.xlsx("_raw_data/PT-TAA-JSE-Daily-1994-2017.xlsx", sheet = i, detectDates = TRUE)
cat("Sheet", i, "loaded with dimensions:", dim(dfS[[i]]), "\n")
}
# Define entities & items to keep
Entities <- c('X1','STEFI','ALBI','J203','J500', sprintf("J5%d", seq(10,90,by=10)))
Items    <- c('Date','TRI','Stefi')
# Clean each sheet
for (i in 1:4) {
tI0 <- sapply(colnames(dfS[[i]]), function(x) any(grepl(paste(Entities, collapse="|"), x)))
tI1 <- sapply(dfS[[i]][2,], function(x) any(grepl(paste(Items, collapse="|"), x)))
tI  <- tI0 & tI1
# Subset and remove header rows
dfS[[i]] <- dfS[[i]][-c(1,2), tI]
names(dfS[[i]])[1] <- "Date"
# Fix column names (remove ":...")
newColNames <- strsplit(colnames(dfS[[i]]), ":")
for(m in 2:length(newColNames)) names(dfS[[i]])[m] <- newColNames[[m]][1]
cat("Sheet", i, "columns after cleaning:", colnames(dfS[[i]]), "\n")
}
# Example fix for ALBI column in dfS[[1]]
dfS[[1]][,2] <- as.numeric(dfS[[1]][,2])  # force numeric, drop text
dfS[[1]] <- dfS[[1]][!is.na(dfS[[1]][,2]), ]  # remove rows where ALBI is NA
# -----------------------------
# 2) Merge into single timeSeries object
# -----------------------------
# Convert first sheet to timeSeries
tsTAA <- timeSeries(dfS[[1]][, 2:ncol(dfS[[1]])], as.Date(dfS[[1]][,1]))
cat("Initial tsTAA dimensions:", dim(tsTAA), "\n")
# Merge remaining sheets
for (i in 2:4) {
tsTmp <- timeSeries(dfS[[i]][, 2:ncol(dfS[[i]])], as.Date(dfS[[i]][,1]))
tsTAA <- cbind(tsTAA, tsTmp)
cat("After merging sheet", i, "dimensions:", dim(tsTAA), "\n")
}
# Rename indices for clarity
setFinCenter(tsTAA) <- "Johannesburg"
names(tsTAA)[grep("TS.1.1", names(tsTAA))] <- "ALBI"
names(tsTAA)[grep("TS.1.2", names(tsTAA))] <- "STEFI"
names(tsTAA)[grep("TS.1", names(tsTAA))] <- "ALSI"
cat("Columns after renaming:", colnames(tsTAA), "\n")
# Ensure all numeric columns are numeric
for (j in 1:ncol(tsTAA)) {
tsTAA[, j] <- as.numeric(tsTAA[, j])
}
# Remove rows with all NAs
tsTAA <- tsTAA[rowSums(is.na(tsTAA)) < ncol(tsTAA), ]
# -----------------------------
# 2a) Convert daily -> monthly (using end-of-month)
# -----------------------------
# Use timeSeries daily2monthly; ensure tsTAA is valid
tsTAA_monthly <- tryCatch(
daily2monthly(tsTAA),
error = function(e) {
stop("Error in daily2monthly: tsTAA might contain non-timeSeries columns or non-numeric values")
}
)
# Compute monthly price index
tsIdx  <- index2wealth(tsTAA_monthly)
# Compute geometric monthly returns
tsGRet <- diff(log(tsIdx))
cat("tsTAA_monthly dimensions:", dim(tsTAA_monthly), "\n")
cat("tsGRet dimensions:", dim(tsGRet), "\n")
cat("Columns in tsGRet:\n"); print(colnames(tsGRet))
### Arithmetic Returns & Robust Missing Data Handling
library(timeSeries)
library(xts)
library(zoo)
# 1) Correct FinCenter / timezone
setFinCenter(tsTAA) <- "Africa/Johannesburg"
summary(dfS[[1]][,2])
head(dfS[[1]], 10)
# 2) Convert daily -> monthly
# Ensure tsTAA is a proper 'timeSeries' object
tsTAA_monthly <- tryCatch(
daily2monthly(tsTAA),
error = function(e) {
message("Error in daily2monthly(): converting tsTAA to xts first")
xts_obj <- as.xts(tsTAA)
apply.monthly(xts_obj, colMeans, na.rm=TRUE)
}
)
summary(tsTAA_monthly[,"ALBI"])
# 3) Compute geometric returns
tsGRet <- diff(log(tsTAA_monthly))
# 4) Fill missing data
tsGRet_filled <- na.locf(as.xts(tsGRet), na.rm = FALSE)
summary(tsGRet_filled[,"ALBI"])
any(!is.na(tsGRet_filled[,"ALBI"]))
# 5) Check for columns that are all NA
cols_allNA <- colSums(!is.na(tsGRet_filled)) == 0
tsGRet_filled <- tsGRet_filled[, !cols_allNA]
# 6) Now convert to arithmetic returns
simple_mat <- exp(as.matrix(tsGRet_filled)) - 1
rets_xts <- xts(simple_mat, order.by = index(tsGRet_filled))
colnames(rets_xts) <- colnames(tsGRet_filled)
# 7) Separate cash
cash_idx <- grep("STEFI", colnames(rets_xts), ignore.case = TRUE)
cash_name <- ifelse(length(cash_idx) > 0, colnames(rets_xts)[cash_idx[1]], NA)
rets_opt <- if(!is.na(cash_name)) rets_xts[, -cash_idx, drop=FALSE] else rets_xts
rets_cash <- if(!is.na(cash_name)) rets_xts[, cash_idx, drop=FALSE] else NULL
# Check results
cat("Assets used for optimisation:\n"); print(colnames(rets_opt))
if(!is.na(cash_name)) cat("Cash excluded from optimisation:", cash_name, "\n")
# -----------------------------
# 5) Tangency Portfolio (no short-selling) - Robust Version
# -----------------------------
compute_tangency_noshort <- function(mu, Sigma, rf=0){
# Ensure numeric and remove NA columns
mu <- as.numeric(mu)
Sigma <- as.matrix(Sigma)
valid_idx <- which(!is.na(mu) & rowSums(is.na(Sigma)) == 0 & colSums(is.na(Sigma)) == 0)
mu <- mu[valid_idx]
Sigma <- Sigma[valid_idx, valid_idx]
n <- length(mu)
if(n == 0) stop("No valid assets to optimize. Check mu and Sigma.")
# Ensure positive definite covariance
Sigma <- Sigma + diag(1e-6, n)
# Tangency portfolio: maximize Sharpe ratio => solve QP once
Dmat <- 2 * Sigma
dvec <- rep(0, n)
# Constraints: sum(w) = 1 (equality), w >= 0 (inequality)
Amat <- cbind(rep(1, n), diag(n))
bvec <- c(1, rep(0, n))
meq  <- 1   # first constraint is equality
sol <- solve.QP(Dmat, dvec, Amat, bvec, meq)
w <- sol$solution
w[w < 1e-8] <- 0
w <- w / sum(w)
# Portfolio stats
port_mean <- sum(w * mu)
port_var  <- as.numeric(t(w) %*% Sigma %*% w)
sharpe    <- (port_mean - rf) / sqrt(port_var)
list(weights = w, mean = port_mean, var = port_var, sharpe = sharpe)
}
# Total number of months
total_months <- nrow(rets_opt)
# Train/test split ratio
train_ratio <- 0.7
train_months <- floor(total_months * train_ratio)
test_months  <- total_months - train_months
# Train/test indices
train_idx <- 1:train_months
test_idx  <- (train_months+1):total_months
# Extract returns
train_rets <- rets_opt[train_idx, ]
test_rets  <- rets_opt[test_idx, ]
# Fill missing data forward/backward
train_rets <- zoo::na.locf(train_rets, na.rm=FALSE)
train_rets <- zoo::na.locf(train_rets, fromLast=TRUE)
test_rets  <- zoo::na.locf(test_rets, na.rm=FALSE)
test_rets  <- zoo::na.locf(test_rets, fromLast=TRUE)
# Keep only assets with valid data
train_rets <- train_rets[, colSums(!is.na(train_rets)) > 0, drop=FALSE]
test_rets  <- test_rets[, colnames(train_rets), drop=FALSE]
# Risk-free rates
rf_train <- if(!is.null(rets_cash)) mean(rets_cash[train_idx,], na.rm=TRUE) else 0
rf_test  <- if(!is.null(rets_cash)) mean(rets_cash[test_idx,], na.rm=TRUE) else 0
# Tangency portfolio
mu_train <- colMeans(train_rets, na.rm=TRUE)
Sigma_train <- cov(train_rets, use="complete.obs")
tang <- compute_tangency_noshort(mu=mu_train, Sigma=Sigma_train, rf=rf_train)
w_hat <- tang$weights
if(is.null(w_hat)) stop("Tangency portfolio weights are NULL. Check your data!")
# Portfolio returns
# -----------------------------
# 7) Compute Portfolio Returns with exact monthly rf
# -----------------------------
# Portfolio returns
port_train <- as.numeric(train_rets %*% w_hat)
port_test  <- as.numeric(test_rets %*% w_hat)
# Monthly risk-free series
rf_train_series <- if(!is.null(rets_cash)) as.numeric(rets_cash[train_idx, ]) else rep(0, length(port_train))
rf_test_series  <- if(!is.null(rets_cash)) as.numeric(rets_cash[test_idx, ]) else rep(0, length(port_test))
# Summary table with exact rf
summary_df <- data.frame(
Period = c("In-Sample", "Out-of-Sample"),
Mean = c(mean(port_train), mean(port_test)),
Variance = c(var(port_train), var(port_test)),
Sharpe = c(mean(port_train - rf_train_series, na.rm=TRUE)/sd(port_train - rf_train_series, na.rm=TRUE),
mean(port_test  - rf_test_series,  na.rm=TRUE)/sd(port_test  - rf_test_series,  na.rm=TRUE))
)
knitr::kable(summary_df, digits=6, caption="In-Sample vs Out-of-Sample Portfolio Statistics (Exact rf)")
# Only keep the assets that were used in optimization
assets_used <- colnames(train_rets)  # columns that match w_hat
weights_df <- data.frame(
Asset  = assets_used,
Weight = w_hat
)
knitr::kable(weights_df, digits=6, caption="Tangency Portfolio Weights (Buy-and-Hold)")
# Extract dates
test_dates <- as.Date(index(rets_xts[test_idx, ]))
# Compute cumulative wealth
port_cum <- cumprod(1 + port_test)
# Plot dataframe
plot_df <- data.frame(Date = test_dates, Cumulative_Wealth = port_cum)
# Plot with year-by-year breaks # Buy-and-Hold Portfolio Cumulative Wealth (OOS)
ggplot(plot_df, aes(x = Date, y = Cumulative_Wealth)) +
geom_line(color = "steelblue") +
scale_x_date(date_labels = "%Y", date_breaks = "1 year") +  # monthly breaks
labs(title = "",
x = "Year", y = "Portfolio Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
rm(list = ls())
# load required libraries
library(openxlsx)
library(timeSeries)
library(xts)
library(zoo)
library(matrixStats)
library(quadprog)
library(knitr)
library(dplyr)
library(ggp2)
rm(list = ls())
# load required libraries
library(openxlsx)
library(timeSeries)
library(xts)
library(zoo)
library(matrixStats)
library(quadprog)
library(knitr)
library(dplyr)
library(ggplot2)
library(tidyr)
# reading in all 4 sheets into a list
dfS <- list()
for (i in 1:4) {
dfS[[i]] <- read.xlsx("_raw_data/PT-TAA-JSE-Daily-1994-2017.xlsx", sheet = i, detectDates = TRUE)
cat("Sheet", i, "loaded with dimensions:", dim(dfS[[i]]), "\n")
}
# define entities and which assets to keep
Entities <- c('X1','STEFI','ALBI','J203','J500', sprintf("J5%d", seq(10,90,by=10)))
Items    <- c('Date','TRI','Stefi')
#cleaning each sheet
for (i in 1:4) {
tI0 <- sapply(colnames(dfS[[i]]), function(x) any(grepl(paste(Entities, collapse="|"), x)))
tI1 <- sapply(dfS[[i]][2,], function(x) any(grepl(paste(Items, collapse="|"), x)))
tI  <- tI0 & tI1
# remove header rows
dfS[[i]] <- dfS[[i]][-c(1,2), tI]
names(dfS[[i]])[1] <- "Date"
newColNames <- strsplit(colnames(dfS[[i]]), ":")
for(m in 2:length(newColNames)) names(dfS[[i]])[m] <- newColNames[[m]][1]
cat("Sheet", i, "columns after cleaning:", colnames(dfS[[i]]), "\n")
}
# fixing ALBI column
dfS[[1]][,2] <- as.numeric(dfS[[1]][,2])
dfS[[1]] <- dfS[[1]][!is.na(dfS[[1]][,2]), ]#removes rows where ALBI is NA
# converts first sheet to timeSeries
tsTAA <- timeSeries(dfS[[1]][, 2:ncol(dfS[[1]])], as.Date(dfS[[1]][,1]))
cat("Initial tsTAA dimensions:", dim(tsTAA), "\n")
# merges remaining sheets
for (i in 2:4) {
tsTmp <- timeSeries(dfS[[i]][, 2:ncol(dfS[[i]])], as.Date(dfS[[i]][,1]))
tsTAA <- cbind(tsTAA, tsTmp)
cat("After merging sheet", i, "dimensions:", dim(tsTAA), "\n")
}
# renaming indices for clarity
setFinCenter(tsTAA) <- "Johannesburg"
names(tsTAA)[grep("TS.1.1", names(tsTAA))] <- "ALBI"
names(tsTAA)[grep("TS.1.2", names(tsTAA))] <- "STEFI"
names(tsTAA)[grep("TS.1", names(tsTAA))] <- "ALSI"
cat("Columns after renaming:", colnames(tsTAA), "\n")
#all numeric columns are numeric
for (j in 1:ncol(tsTAA)) {
tsTAA[, j] <- as.numeric(tsTAA[, j])
}
#remove rows with all NAs
tsTAA <- tsTAA[rowSums(is.na(tsTAA)) < ncol(tsTAA), ]
# Using timeSeries daily2monthly and ensure tsTAA is valid
tsTAA_monthly <- tryCatch(
daily2monthly(tsTAA),
error = function(e) {
stop("Error in daily2monthly: tsTAA might contain non-timeSeries columns or non-numeric values")
}
)
#  monthly price index
tsIdx  <- index2wealth(tsTAA_monthly)
# geometric monthly returns
tsGRet <- diff(log(tsIdx))
cat("tsTAA_monthly dimensions:", dim(tsTAA_monthly), "\n")
cat("tsGRet dimensions:", dim(tsGRet), "\n")
cat("Columns in tsGRet:\n"); print(colnames(tsGRet))
setFinCenter(tsTAA) <- "Africa/Johannesburg"
summary(dfS[[1]][,2])
# Checks that tsTAA is a proper 'timeSeries' object
tsTAA_monthly <- tryCatch(
daily2monthly(tsTAA),
error = function(e) {
message("Error in daily2monthly(): converting tsTAA to xts first")
xts_obj <- as.xts(tsTAA)
apply.monthly(xts_obj, colMeans, na.rm=TRUE)
}
)
#geometric returns
tsGRet <- diff(log(tsTAA_monthly))
#  fill missing data using LOCF
tsGRet_filled <- na.locf(as.xts(tsGRet), na.rm = FALSE)
summary(tsGRet_filled[,"ALBI"])
any(!is.na(tsGRet_filled[,"ALBI"]))
#checking for columns that are all NA
cols_allNA <- colSums(!is.na(tsGRet_filled)) == 0
tsGRet_filled <- tsGRet_filled[, !cols_allNA]
# converting to arithmetic returns
simple_mat <- exp(as.matrix(tsGRet_filled)) - 1
rets_xts <- xts(simple_mat, order.by = index(tsGRet_filled))
colnames(rets_xts) <- colnames(tsGRet_filled)
# Excludes cash asset
cash_idx <- grep("STEFI", colnames(rets_xts), ignore.case = TRUE)
cash_name <- ifelse(length(cash_idx) > 0, colnames(rets_xts)[cash_idx[1]], NA)
rets_opt <- if(!is.na(cash_name)) rets_xts[, -cash_idx, drop=FALSE] else rets_xts
rets_cash <- if(!is.na(cash_name)) rets_xts[, cash_idx, drop=FALSE] else NULL
cat("Assets used for optimisation:\n"); print(colnames(rets_opt))
if(!is.na(cash_name)) cat("Cash excluded from optimisation:", cash_name, "\n")
tan.port <- function(mu, Sigma, rf=0){
mu <- as.numeric(mu)
Sigma <- as.matrix(Sigma)
valid_idx <- which(!is.na(mu) & rowSums(is.na(Sigma)) == 0 & colSums(is.na(Sigma)) == 0)
mu <- mu[valid_idx]
Sigma <- Sigma[valid_idx, valid_idx]
n <- length(mu)
if(n == 0) stop("No valid assets to optimize. Check mu and Sigma.")
# positive definite covariance
Sigma <- Sigma + diag(1e-6, n)
#maximize Sharpe ratio
Dmat <- 2 * Sigma
dvec <- rep(0, n)
# Constraints which are sum(w) = 1 and w >= 0
Amat <- cbind(rep(1, n), diag(n))
bvec <- c(1, rep(0, n))
meq  <- 1
sol <- solve.QP(Dmat, dvec, Amat, bvec, meq)
w <- sol$solution
w[w < 1e-8] <- 0
w <- w / sum(w)
port_mean <- sum(w * mu)
port_var  <- as.numeric(t(w) %*% Sigma %*% w)
sharpe    <- (port_mean - rf) / sqrt(port_var)
list(weights = w, mean = port_mean, var = port_var, sharpe = sharpe)
}
tot.months <- nrow(rets_opt)
train.r <- 0.7
train.m <- floor(tot.months * train.r)
test.m  <- tot.months - train.m
# indices
train_idx <- 1:train.m
tst.idx  <- (train.m+1):tot.months
#returns
train_rets <- rets_opt[train_idx, ]
tst.rets  <- rets_opt[tst.idx, ]
# fill missing data using locf
train_rets <- na.locf(train_rets, na.rm=FALSE)
train_rets <- na.locf(train_rets, fromLast=TRUE)
tst.rets  <- na.locf(tst.rets, na.rm=FALSE)
tst.rets  <- na.locf(tst.rets, fromLast=TRUE)
#only assets with valid data
train_rets <- train_rets[, colSums(!is.na(train_rets)) > 0, drop=FALSE]
tst.rets  <- tst.rets[, colnames(train_rets), drop=FALSE]
# Risk-free rates
rf_train <- if(!is.null(rets_cash)) mean(rets_cash[train_idx,], na.rm=TRUE) else 0
rf_test  <- if(!is.null(rets_cash)) mean(rets_cash[tst.idx,], na.rm=TRUE) else 0
# Tangency portfolio
mu_train <- colMeans(train_rets, na.rm=TRUE)
Sigma_train <- cov(train_rets, use="complete.obs")
tang <- tan.port(mu=mu_train, Sigma=Sigma_train, rf=rf_train)
w_hat <- tang$weights
if(is.null(w_hat)) stop("Tangency portfolio weights are NULL. Check your data!")
#Portfolio Returns with exact monthly rf
# Portfolio returns
port_train <- as.numeric(train_rets %*% w_hat)
port_test  <- as.numeric(tst.rets %*% w_hat)
# monthly risk-free series
rf_train_series <- if(!is.null(rets_cash)) as.numeric(rets_cash[train_idx, ]) else rep(0, length(port_train))
rf_tst.series  <- if(!is.null(rets_cash)) as.numeric(rets_cash[tst.idx, ]) else rep(0, length(port_test))
summary_df <- data.frame(
Period = c("In-Sample", "Out-of-Sample"),
Mean = c(mean(port_train), mean(port_test)),
Variance = c(var(port_train), var(port_test)),
Sharpe = c(mean(port_train - rf_train_series, na.rm=TRUE)/sd(port_train - rf_train_series, na.rm=TRUE),
mean(port_test  - rf_tst.series,  na.rm=TRUE)/sd(port_test  - rf_tst.series,  na.rm=TRUE))
)
knitr::kable(summary_df, digits=6, caption="In-Sample vs Out-of-Sample Portfolio Statistics (Exact rf)")
# Only the assets that were used in optimization
assets_used <- colnames(train_rets)  #
weights_df <- data.frame(
Asset  = assets_used,
Weight = w_hat
)
knitr::kable(weights_df, digits=6, caption="Tangency Portfolio Weights (Buy-and-Hold)")
tst.dates <- as.Date(index(rets_xts[tst.idx, ]))
# cumulative wealth
port_cum <- cumprod(1 + port_test)
plot_df <- data.frame(Date = tst.dates, Cumulative_Wealth = port_cum)
#Buy-and-Hold Portfolio Cumulative Wealth (OOS)
ggplot(plot_df, aes(x = Date, y = Cumulative_Wealth)) +
geom_line(color = "steelblue") +
scale_x_date(date_labels = "%Y", date_breaks = "1 year") +  # monthly breaks
labs(title = "",
x = "Year", y = "Portfolio Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
final_ret <- tail(port_cum, 1)
tang_ret  <- prod(1 + tst.rets %*% w_hat) - 1
BH_summary <- data.frame(
Window = 1,
BH_Return = final_ret,
Tangency_Expected = tang_ret
)
knitr::kable(BH_summary, digits=4, caption="Buy-and-Hold Cumulative Return vs Tangency Expected Return")
rm(list = ls())
# load required libraries
library(openxlsx)
library(timeSeries)
library(xts)
library(zoo)
library(matrixStats)
library(quadprog)
library(knitr)
library(dplyr)
library(ggp2)
