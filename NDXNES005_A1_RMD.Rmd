---
title: "Portfolio Theory: Assignment 1"
subtitle: "Appendix B: R Code"
author: "Nesan Naidoo : NDXNES005"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    latex_engine: xelatex
    keep_tex: true   # correct spelling with underscore
fontsize: 12pt
header-includes:
  - \usepackage{setspace}
  - \onehalfspacing
  - \usepackage{etoolbox}
  - \apptocmd{\thebibliography}{\setlength{\itemsep}{1.0\baselineskip}}{}{}
  - \usepackage{amsmath}
  - \usepackage{amssymb}
  - \usepackage{float}
  - \usepackage{graphicx}
  - \usepackage{fvextra}
  - \usepackage{adjustbox}
  - \usepackage{tabu}
  - \usepackage{threeparttable}
execute:
  warning: FALSE
  message: FALSE
  fig.width: 7        
  fig.height: 5       
results: asis
bibliography: Sources.bib  
nocite: '@*'
csl: _citation_style/apa.csl    
---

# PART II : Backtest Performance of the Tangency Portfolio

Coding for this section was completed using RStudio 2024.09.0+375 ("Cranberry Hibiscus" Release) and was based on R and MATLAB code provided by Professor Tim Gebbie(STA4028Z).

## Experiment 1 : In-Sample and Out-Of-Sample Sharpe Ratios

### 1.1 Libraries [@Tim_prep]

```{r}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  fig.width  = 7,
  fig.height = 5
)

suppressPackageStartupMessages({
  library(openxlsx)     
  library(timeSeries)   
  library(xts)          
  library(zoo)          
  library(matrixStats) 
  library(quadprog)     
  library(knitr)        
  library(dplyr)        
  library(ggplot2)      
  library(tidyr)        
})
      
```

### 1.2 Load data and preprocessing [@Tim_prep]

```{r}
# reading in all 4 sheets into a list
dfS <- list()
for (i in 1:4) {
  dfS[[i]] <- read.xlsx("_raw_data/PT-TAA-JSE-Daily-1994-2017.xlsx", sheet = i, detectDates = TRUE)
  cat("Sheet", i, "loaded with dimensions:", dim(dfS[[i]]), "\n")
}

# define entities and which assets to keep
Entities <- c('X1','STEFI','ALBI','J203','J500', sprintf("J5%d", seq(10,90,by=10)))
Items    <- c('Date','TRI','Stefi')

#cleaning each sheet
for (i in 1:4) {
  tI0 <- sapply(colnames(dfS[[i]]), function(x) any(grepl(paste(Entities, collapse="|"), x)))
  tI1 <- sapply(dfS[[i]][2,], function(x) any(grepl(paste(Items, collapse="|"), x)))
  tI  <- tI0 & tI1
  
  # remove header rows
  dfS[[i]] <- dfS[[i]][-c(1,2), tI]
  names(dfS[[i]])[1] <- "Date"
  
  newColNames <- strsplit(colnames(dfS[[i]]), ":")
  for(m in 2:length(newColNames)) names(dfS[[i]])[m] <- newColNames[[m]][1]
  
  cat("Sheet", i, "columns after cleaning:", colnames(dfS[[i]]), "\n")
}

# fixing ALBI column
dfS[[1]][,2] <- as.numeric(dfS[[1]][,2])  
dfS[[1]] <- dfS[[1]][!is.na(dfS[[1]][,2]), ]#removes rows where ALBI is NA

```

### 1.3 Merge into single timeSeries object [@Tim_prep]

```{r}

# converts first sheet to timeSeries
tsTAA <- timeSeries(dfS[[1]][, 2:ncol(dfS[[1]])], as.Date(dfS[[1]][,1]))
cat("Initial tsTAA dimensions:", dim(tsTAA), "\n")

# merges remaining sheets
for (i in 2:4) {
  tsTmp <- timeSeries(dfS[[i]][, 2:ncol(dfS[[i]])], as.Date(dfS[[i]][,1]))
  tsTAA <- cbind(tsTAA, tsTmp)
  cat("After merging sheet", i, "dimensions:", dim(tsTAA), "\n")
}
# renaming indices for clarity
setFinCenter(tsTAA) <- "Johannesburg"
names(tsTAA)[grep("TS.1.1", names(tsTAA))] <- "ALBI"
names(tsTAA)[grep("TS.1.2", names(tsTAA))] <- "STEFI"
names(tsTAA)[grep("TS.1", names(tsTAA))] <- "ALSI"

cat("Columns after renaming:", colnames(tsTAA), "\n")

#all numeric columns are numeric
for (j in 1:ncol(tsTAA)) {
  tsTAA[, j] <- as.numeric(tsTAA[, j])
}
#remove rows with all NAs
tsTAA <- tsTAA[rowSums(is.na(tsTAA)) < ncol(tsTAA), ]

# Using timeSeries daily2monthly and ensure tsTAA is valid
tsTAA_monthly <- tryCatch(
  daily2monthly(tsTAA),
  error = function(e) {
    stop("Error in daily2monthly: tsTAA might contain non-timeSeries columns or non-numeric values")
  }
)

#  monthly price index
tsIdx  <- index2wealth(tsTAA_monthly)

# geometric monthly returns
tsGRet <- diff(log(tsIdx))

cat("tsTAA_monthly dimensions:", dim(tsTAA_monthly), "\n")
cat("tsGRet dimensions:", dim(tsGRet), "\n")
cat("Columns in tsGRet:\n"); print(colnames(tsGRet))
```

### 1.4 Arithmetic Returns [@Tim_BTmlx]

```{r}

setFinCenter(tsTAA) <- "Africa/Johannesburg"
summary(dfS[[1]][,2])

# Checks that tsTAA is a proper 'timeSeries' object
tsTAA_monthly <- tryCatch(
  daily2monthly(tsTAA),
  error = function(e) {
    message("Error in daily2monthly(): converting tsTAA to xts first")
    xts_obj <- as.xts(tsTAA)
    apply.monthly(xts_obj, colMeans, na.rm=TRUE)
  }
)



#geometric returns
tsGRet <- diff(log(tsTAA_monthly))

#  fill missing data using LOCF
tsGRet_filled <- na.locf(as.xts(tsGRet), na.rm = FALSE)
summary(tsGRet_filled[,"ALBI"])
any(!is.na(tsGRet_filled[,"ALBI"]))

#checking for columns that are all NA
cols_allNA <- colSums(!is.na(tsGRet_filled)) == 0
tsGRet_filled <- tsGRet_filled[, !cols_allNA]

# converting to arithmetic returns
simple_mat <- exp(as.matrix(tsGRet_filled)) - 1
rets_xts <- xts(simple_mat, order.by = index(tsGRet_filled))
colnames(rets_xts) <- colnames(tsGRet_filled)

# Excludes cash asset
cash_idx <- grep("STEFI", colnames(rets_xts), ignore.case = TRUE)
cash_name <- ifelse(length(cash_idx) > 0, colnames(rets_xts)[cash_idx[1]], NA)

rets_opt <- if(!is.na(cash_name)) rets_xts[, -cash_idx, drop=FALSE] else rets_xts
rets_cash <- if(!is.na(cash_name)) rets_xts[, cash_idx, drop=FALSE] else NULL

cat("Assets used for optimisation:\n"); print(colnames(rets_opt))
if(!is.na(cash_name)) cat("Cash excluded from optimisation:", cash_name, "\n")
```

### 1.5 Tangency Portfolio (specifications: fully invested,no short-selling)[@Tim_BTmlx; @Tim_prep]

```{r}
tan.port <- function(mu, Sigma, rf=0){
  mu <- as.numeric(mu)
  Sigma <- as.matrix(Sigma)
  valid_idx <- which(!is.na(mu) & rowSums(is.na(Sigma)) == 0 & colSums(is.na(Sigma)) == 0)
  mu <- mu[valid_idx]
  Sigma <- Sigma[valid_idx, valid_idx]
  n <- length(mu)
  if(n == 0) stop("No valid assets to optimize. Check mu and Sigma.")
  
  # positive definite covariance
  Sigma <- Sigma + diag(1e-6, n)
  #maximize Sharpe ratio 
  Dmat <- 2 * Sigma
  dvec <- rep(0, n)
  # Constraints which are sum(w) = 1 and w >= 0 
  Amat <- cbind(rep(1, n), diag(n))
  bvec <- c(1, rep(0, n))
  meq  <- 1   
  sol <- solve.QP(Dmat, dvec, Amat, bvec, meq)
  w <- sol$solution
  w[w < 1e-8] <- 0
  w <- w / sum(w)
  port_mean <- sum(w * mu)
  port_var  <- as.numeric(t(w) %*% Sigma %*% w)
  sharpe    <- (port_mean - rf) / sqrt(port_var)
  
  list(weights = w, mean = port_mean, var = port_var, sharpe = sharpe)
}

```

### 1.6 In-Sample and Out-of-Sample Split

```{r}

tot.months <- nrow(rets_opt)
train.r <- 0.7
train.m <- floor(tot.months * train.r)
test.m  <- tot.months - train.m
# indices
train_idx <- 1:train.m
tst.idx  <- (train.m+1):tot.months
#returns
train_rets <- rets_opt[train_idx, ]
tst.rets  <- rets_opt[tst.idx, ]
# fill missing data using locf
train_rets <- na.locf(train_rets, na.rm=FALSE)
train_rets <- na.locf(train_rets, fromLast=TRUE)
tst.rets  <- na.locf(tst.rets, na.rm=FALSE)
tst.rets  <- na.locf(tst.rets, fromLast=TRUE)
#only assets with valid data
train_rets <- train_rets[, colSums(!is.na(train_rets)) > 0, drop=FALSE]
tst.rets  <- tst.rets[, colnames(train_rets), drop=FALSE]
# Risk-free rates
rf_train <- if(!is.null(rets_cash)) mean(rets_cash[train_idx,], na.rm=TRUE) else 0
rf_test  <- if(!is.null(rets_cash)) mean(rets_cash[tst.idx,], na.rm=TRUE) else 0
# Tangency portfolio
mu_train <- colMeans(train_rets, na.rm=TRUE)
Sigma_train <- cov(train_rets, use="complete.obs")

tang <- tan.port(mu=mu_train, Sigma=Sigma_train, rf=rf_train)
w_hat <- tang$weights
if(is.null(w_hat)) stop("Tangency portfolio weights are NULL. Check your data!")

```

### 1.7 In-Sample & Out-of-Sample Portfolio Stats

```{r}
#Portfolio Returns with exact monthly rf
# Portfolio returns
port_train <- as.numeric(train_rets %*% w_hat)
port_test  <- as.numeric(tst.rets %*% w_hat)

# monthly risk-free series
rf_train_series <- if(!is.null(rets_cash)) as.numeric(rets_cash[train_idx, ]) else rep(0, length(port_train))
rf_tst.series  <- if(!is.null(rets_cash)) as.numeric(rets_cash[tst.idx, ]) else rep(0, length(port_test))

summary_df <- data.frame(
  Period = c("In-Sample", "Out-of-Sample"),
  Mean = c(mean(port_train), mean(port_test)),
  Variance = c(var(port_train), var(port_test)),
  Sharpe = c(mean(port_train - rf_train_series, na.rm=TRUE)/sd(port_train - rf_train_series, na.rm=TRUE),
             mean(port_test  - rf_tst.series,  na.rm=TRUE)/sd(port_test  - rf_tst.series,  na.rm=TRUE))
)

knitr::kable(summary_df, digits=6, caption="In-Sample vs Out-of-Sample Portfolio Statistics (Exact rf)")

```

### 1.8 Buy-and-Hold portfolio weights table

```{r}
# Only the assets that were used in optimization
assets_used <- colnames(train_rets)  #
weights_df <- data.frame(
  Asset  = assets_used,
  Weight = w_hat
)
knitr::kable(weights_df, digits=6, caption="Tangency Portfolio Weights (Buy-and-Hold)")
```

### 1.9 Cumulative wealth -Buy and Hold

```{r}
tst.dates <- as.Date(index(rets_xts[tst.idx, ]))  
# cumulative wealth
port_cum <- cumprod(1 + port_test)
plot_df <- data.frame(Date = tst.dates, Cumulative_Wealth = port_cum)

#Buy-and-Hold Portfolio Cumulative Wealth (OOS)
ggplot(plot_df, aes(x = Date, y = Cumulative_Wealth)) +
  geom_line(color = "steelblue") +
  scale_x_date(date_labels = "%Y", date_breaks = "1 year") +  # monthly breaks
  labs(title = "",
       x = "Year", y = "Portfolio Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

### 1.10 Final cumulative return

```{r}
final_ret <- tail(port_cum, 1)
tang_ret  <- prod(1 + tst.rets %*% w_hat) - 1
BH_summary <- data.frame(
  Window = 1,
  BH_Return = final_ret,
  Tangency_Expected = tang_ret
)
knitr::kable(BH_summary, digits=4, caption="Buy-and-Hold Cumulative Return vs Tangency Expected Return")
```

## Experiment 2 : Out-Of-Sample Backtesting using a Rolling Window

### 2.1 Libraries [@Tim_prep]

```{r}
# load required libraries
suppressPackageStartupMessages({
library(openxlsx)     
library(timeSeries)   
library(xts)          
library(zoo)          
library(matrixStats) 
library(quadprog)     
library(knitr)        
library(dplyr)        
library(ggplot2)      
library(tidyr)  
})
```

### 2.2 Load data and preprocessing [@Tim_prep]

```{r}
# reading in all 4 sheets into a list
dfS <- list()
for (i in 1:4) {
  dfS[[i]] <- read.xlsx("_raw_data/PT-TAA-JSE-Daily-1994-2017.xlsx", sheet = i, detectDates = TRUE)
  cat("Sheet", i, "loaded with dimensions:", dim(dfS[[i]]), "\n")
}

# define entities and which assets to keep
Entities <- c('X1','STEFI','ALBI','J203','J500', sprintf("J5%d", seq(10,90,by=10)))
Items    <- c('Date','TRI','Stefi')

#cleaning each sheet
for (i in 1:4) {
  tI0 <- sapply(colnames(dfS[[i]]), function(x) any(grepl(paste(Entities, collapse="|"), x)))
  tI1 <- sapply(dfS[[i]][2,], function(x) any(grepl(paste(Items, collapse="|"), x)))
  tI  <- tI0 & tI1
  
  # remove header rows
  dfS[[i]] <- dfS[[i]][-c(1,2), tI]
  names(dfS[[i]])[1] <- "Date"
  
  newColNames <- strsplit(colnames(dfS[[i]]), ":")
  for(m in 2:length(newColNames)) names(dfS[[i]])[m] <- newColNames[[m]][1]
  
  cat("Sheet", i, "columns after cleaning:", colnames(dfS[[i]]), "\n")
}

# fixing ALBI column
dfS[[1]][,2] <- as.numeric(dfS[[1]][,2])  
dfS[[1]] <- dfS[[1]][!is.na(dfS[[1]][,2]), ]#removes rows where ALBI is NA

```

### 2.3 Merge into single timeSeries object [@Tim_prep]

```{r}

# converts first sheet to timeSeries
tsTAA <- timeSeries(dfS[[1]][, 2:ncol(dfS[[1]])], as.Date(dfS[[1]][,1]))
cat("Initial tsTAA dimensions:", dim(tsTAA), "\n")

# merges remaining sheets
for (i in 2:4) {
  tsTmp <- timeSeries(dfS[[i]][, 2:ncol(dfS[[i]])], as.Date(dfS[[i]][,1]))
  tsTAA <- cbind(tsTAA, tsTmp)
  cat("After merging sheet", i, "dimensions:", dim(tsTAA), "\n")
}
# renaming indices for clarity
setFinCenter(tsTAA) <- "Johannesburg"
names(tsTAA)[grep("TS.1.1", names(tsTAA))] <- "ALBI"
names(tsTAA)[grep("TS.1.2", names(tsTAA))] <- "STEFI"
names(tsTAA)[grep("TS.1", names(tsTAA))] <- "ALSI"

cat("Columns after renaming:", colnames(tsTAA), "\n")

#all numeric columns are numeric
for (j in 1:ncol(tsTAA)) {
  tsTAA[, j] <- as.numeric(tsTAA[, j])
}
#remove rows with all NAs
tsTAA <- tsTAA[rowSums(is.na(tsTAA)) < ncol(tsTAA), ]

# Using timeSeries daily2monthly and ensure tsTAA is valid
tsTAA_monthly <- tryCatch(
  daily2monthly(tsTAA),
  error = function(e) {
    stop("Error in daily2monthly: tsTAA might contain non-timeSeries columns or non-numeric values")
  }
)

#  monthly price index
tsIdx  <- index2wealth(tsTAA_monthly)

# geometric monthly returns
tsGRet <- diff(log(tsIdx))

cat("tsTAA_monthly dimensions:", dim(tsTAA_monthly), "\n")
cat("tsGRet dimensions:", dim(tsGRet), "\n")
cat("Columns in tsGRet:\n"); print(colnames(tsGRet))
```

### 2.4 Arithmetic Returns [@Tim_BTmlx]

```{r}

setFinCenter(tsTAA) <- "Africa/Johannesburg"
summary(dfS[[1]][,2])

# Checks that tsTAA is a proper 'timeSeries' object
tsTAA_monthly <- tryCatch(
  daily2monthly(tsTAA),
  error = function(e) {
    message("Error in daily2monthly(): converting tsTAA to xts first")
    xts_obj <- as.xts(tsTAA)
    apply.monthly(xts_obj, colMeans, na.rm=TRUE)
  }
)



#geometric returns
tsGRet <- diff(log(tsTAA_monthly))

#  fill missing data using LOCF
tsGRet_filled <- na.locf(as.xts(tsGRet), na.rm = FALSE)
summary(tsGRet_filled[,"ALBI"])
any(!is.na(tsGRet_filled[,"ALBI"]))

#checking for columns that are all NA
cols_allNA <- colSums(!is.na(tsGRet_filled)) == 0
tsGRet_filled <- tsGRet_filled[, !cols_allNA]

# converting to arithmetic returns
simple_mat <- exp(as.matrix(tsGRet_filled)) - 1
rets_xts <- xts(simple_mat, order.by = index(tsGRet_filled))
colnames(rets_xts) <- colnames(tsGRet_filled)

# Excludes cash asset
cash_idx <- grep("STEFI", colnames(rets_xts), ignore.case = TRUE)
cash_name <- ifelse(length(cash_idx) > 0, colnames(rets_xts)[cash_idx[1]], NA)

rets_opt <- if(!is.na(cash_name)) rets_xts[, -cash_idx, drop=FALSE] else rets_xts
rets_cash <- if(!is.na(cash_name)) rets_xts[, cash_idx, drop=FALSE] else NULL

cat("Assets used for optimisation:\n"); print(colnames(rets_opt))
if(!is.na(cash_name)) cat("Cash excluded from optimisation:", cash_name, "\n")
```

### 2.5 Tangency Portfolio [@Tim_BTmlx; @Tim_prep]

```{r}
tan.port <- function(mu, Sigma, rf=0, targets=seq(0.001,0.05,length.out=200)){
  n <- length(mu)
  Dmat <- 2*(Sigma + diag(1e-8,n))  # ensure PD covariance
  best <- list(sharpe=-Inf)
  
  for(tgt in targets){
    gamma <- as.numeric(mu - rf)
    Amat <- cbind(gamma, -gamma, rep(1,n), -rep(1,n), diag(n))
    bvec <- c(tgt, -tgt, 1, -1, rep(0,n))
    sol <- try(solve.QP(Dmat, dvec=rep(0,n), Amat=as.matrix(Amat), bvec=bvec, meq=0), silent=TRUE)
    if(inherits(sol,"try-error")) next
    w <- sol$solution
    w[w<1e-8] <- 0
    if(sum(w)<=0) next
    w <- w/sum(w)
    port_mean <- sum(w*mu)
    port_var  <- as.numeric(t(w) %*% Sigma %*% w)
    if(port_var<=0) next
    sr <- (port_mean - rf)/sqrt(port_var)
    if(sr > best$sharpe) best <- list(weights=w, target=tgt, sharpe=sr, mean=port_mean, var=port_var)
  }
  return(best)
}
```

### 2.6 Rolling Window Experiment [@Tim_BTmlx; @Tim_prep]

```{r}
train.m <- 60 # 5 year period
test.m  <- 12 # 1 year period
roll_step <- 1 #1 month increments
n_obs <- nrow(rets_opt)
start_idxs <- seq(1, n_obs - train.m - test.m + 1, by=roll_step)
results <- list()

for(i in seq_along(start_idxs)){
  s <- start_idxs[i]
  train_idx <- s:(s+train.m-1)
  tst.idx  <- (s+train.m):(s+train.m+test.m-1)
  
  train_rets <- rets_opt[train_idx, , drop=FALSE]
  tst.rets  <- rets_opt[tst.idx, , drop=FALSE]
  
  if(any(!is.finite(as.matrix(train_rets))) || any(!is.finite(as.matrix(tst.rets)))) next
  
  mu_train    <- colMeans(train_rets, na.rm=TRUE)
 Sigma_train <- cov(as.matrix(train_rets), use="complete.obs")

  rf_train    <- if(!is.null(rets_cash)) mean(rets_cash[train_idx, ], na.rm=TRUE) else 0
  rf_test     <- if(!is.null(rets_cash)) mean(rets_cash[tst.idx, ], na.rm=TRUE) else 0
  
  # Skip invalid windows
  if(any(!is.finite(mu_train)) || !is.finite(rf_train)) next
  upper_targ <- max(0.06, max(mu_train, na.rm=TRUE) - rf_train)
  if(!is.finite(upper_targ) || upper_targ <= 0) next
  
  targ_grid <- seq(0.0005, upper_targ, length.out=300)
  tang <- tan.port(mu=mu_train, Sigma=Sigma_train, rf=rf_train, targets=targ_grid)
  if(is.null(tang$weights)) next
  
  w_hat <- tang$weights
  port_train <- as.numeric(as.matrix(train_rets) %*% w_hat)
  port_test  <- as.numeric(as.matrix(tst.rets) %*% w_hat)

  
  results[[length(results)+1]] <- list(
    train_period = paste(index(train_rets)[1], index(train_rets)[nrow(train_rets)], sep=" / "),
    tst.period  = paste(index(tst.rets)[1], index(tst.rets)[nrow(tst.rets)], sep=" / "),
    mu_IS = mean(port_train, na.rm=TRUE),
    var_IS= var(port_train, na.rm=TRUE),
    SR_IS =(mean(port_train, na.rm=TRUE)-rf_train)/sqrt(var(port_train, na.rm=TRUE)),
    mu_OOS= mean(port_test, na.rm=TRUE),
    var_OOS=var(port_test, na.rm=TRUE),
    SR_OOS=(mean(port_test, na.rm=TRUE)-rf_test)/sqrt(var(port_test, na.rm=TRUE)),
    weights = w_hat,
    assets  = colnames(rets_opt)
  )
}

summary_df <- do.call(rbind, lapply(results, function(x) data.frame(
  train=x$train_period, test=x$tst.period,
  mu_IS=x$mu_IS, var_IS=x$var_IS, SR_IS=x$SR_IS,
  mu_OOS=x$mu_OOS, var_OOS=x$var_OOS, SR_OOS=x$SR_OOS
)))
knitr::kable(
  head(summary_df, 15),
  digits = 4,
  caption = "In-sample vs Out-of-sample Portfolio Statistics"
)


```

### Plotting In Sample vs Out Of Sample Statistics

```{r}

p.dates <- as.Date(sapply(summary_df$test, function(x) {
  tail(strsplit(x, " / ")[[1]], 1)
}), format = "%Y-%m-%d")
summary_df$Date <- p.dates  

p.long <- summary_df |>
  select(Date, mu_IS, var_IS, SR_IS, mu_OOS, var_OOS, SR_OOS) |>
  pivot_longer(-Date, names_to = "Metric", values_to = "Value") |>
  mutate(
    Type   = ifelse(grepl("_IS", Metric), "In-Sample", "Out-of-Sample"),
    Metric = gsub("_(IS|OOS)", "", Metric)  
  ) |>
  mutate(
    Metric = case_when(
      Metric == "mu"  ~ "Mean",
      Metric == "var" ~ "Variance",TRUE ~ Metric
    ))

# Mean and Variance In-Sample vs Out-of-Sample Mean & Variance
p1<- p.long |>
  filter(Metric %in% c("Mean", "Variance")) |>
  ggplot(aes(x = Date, y = Value, color = Metric, linetype = Type)) +
  geom_line(linewidth = 0.9) +
  labs(
    title = "",
    x = "Date", y = "Value",
    color = "Measure", linetype = "Sample"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Sharpe Ratios In-Sample vs Out-of-Sample Sharpe Ratios
p2 <- p.long |>
  filter(Metric == "SR") |>
  ggplot(aes(x = Date, y = Value, color = Type, linetype = Type)) +
  geom_line(linewidth = 0.9) +
  labs(
    title = "",
    x = "Date", y = "Sharpe Ratio",
    color = "Sample", linetype = "Sample"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p1
p2

```

### 2.7 Buy and Hold Portfolio Simulation

```{r}

# This section calculates portfolio returns, update weights due to price changes, renormalises, and accumulate portfolio value over the test period

BH_results <- list()

for(idx in seq_along(results)) {
  
  # test period dates from results
  tst.period <- results[[idx]]$tst.period
  tst.start <- as.Date(substr(tst.period,1,10))
  tst.end   <- as.Date(substr(tst.period,14,23))
 tst.rets <- rets_opt[as.Date(index(rets_opt)) >= tst.start & 
                       as.Date(index(rets_opt)) <= tst.end, ,drop=FALSE]

  w0 <- results[[idx]]$weights
  n_assets <- ncol(tst.rets)
  n_obs <- nrow(tst.rets)
  
  # if tst.rets is empty
  if(n_obs == 0) next
  
  Wts <- matrix(0, nrow=n_obs, ncol=n_assets)
  portRet <- numeric(n_obs)
  portPrc <- numeric(n_obs)
  portPrc[1] <- 1
  Wts[1,] <- w0
  
  for(t in 1:n_obs){
    portRet[t] <- sum(Wts[t,] * as.numeric(tst.rets[t,]))
    portPrc[t] <- ifelse(t==1, 1*(1+portRet[t]), portPrc[t-1]*(1+portRet[t]))
    
    if(t < n_obs){
      Wts[t+1,] <- Wts[t,] * (1 + as.numeric(tst.rets[t,]))
      Wts[t+1,] <- Wts[t+1,] / sum(Wts[t+1,])
    }
  }
  
  BH_results[[idx]] <- list(
    weights=Wts,
    asset_names=colnames(tst.rets),
    portPrc=portPrc,
    portRet=portRet,
    dates=index(tst.rets)
  )
}


```

### 2.8 Final cumulative return

```{r}
plot_df <- pivot_longer(BH_summary, cols = c(BH_Return, Tangency_Expected),names_to = "Strategy", values_to = "Value")

ggplot(plot_df, aes(x = Window, y = Value, color = Strategy)) +
  geom_line(linewidth = 0.9) +
  geom_point(size = 1.5) +
  labs(
    title = "",
    x = "Test Window", y = "Cumulative Return",
    color = "Portfolio Strategy"
  ) +
  scale_color_manual(
    values = c("BH_Return" = "red", "Tangency_Expected" = "blue"),
    labels = c("BH_Return" = "Buy-and-Hold", "Tangency_Expected" = "Tangency Portfolio Expected")
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))

```

### 2.9 Tangency Portfolio Weights using heatmap

```{r}
weights_df <- do.call(rbind, lapply(seq_along(results), function(i) {
  n_assets <- length(results[[i]]$weights)
  data.frame(
    Window = i, # numeric window index
    Asset  = results[[i]]$assets, #asset names
    Weight = results[[i]]$weights,#corresponding weights
    stringsAsFactors = FALSE
  )
}))

 # Tangency Portfolio Weights Evolution
ggplot(weights_df, aes(x=Window, y=Asset, fill=Weight)) +
  geom_tile(color="white") +
  scale_fill_gradient(low="white", high="steelblue") +
  scale_x_continuous(
    breaks = seq(min(weights_df$Window), max(weights_df$Window), by=5) 
  ) +
  labs(
    title="",
    x="Training Window", y="Asset", fill="Weight"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle=45, hjust=1))


```

### 2.10 Cumulative Out-of-Sample Performance vs Buy Hold

```{r}
#out-of-sample returns 
OOS_ret <- sapply(results, function(x) {
  val <- x$mu_OOS
  if(is.null(val) || !is.finite(val)) return(NA)
  as.numeric(val)
})
#remove NAs
OOS_ret <- OOS_ret[!is.na(OOS_ret)]
OOS_ret <- as.numeric(OOS_ret) 
#Calculate cumulative wealth
cum_OOS <- cumprod(1 + OOS_ret)
#  Buy-and-Hold
BH_ret <- sapply(BH_results, function(x) {
  if(is.null(x$portRet)) return(NA)
  mean(as.numeric(x$portRet), na.rm=TRUE)
})
BH_ret <- BH_ret[!is.na(BH_ret)]
BH_ret <- as.numeric(BH_ret)
cum_BH <- cumprod(1 + BH_ret)

## keeps results with valid numeric data
val.res <- results[sapply(results, function(x) !is.null(x$mu_OOS) && is.finite(x$mu_OOS))]

#end-of-test-period dates as character
p.dates_char <- sapply(val.res, function(x) {
  tail(strsplit(x$tst.period, " / ")[[1]], 1)
})

p.dates <- as.Date(unlist(p.dates_char), format="%Y-%m-%d") 
plot_df <- data.frame(
  Date     = p.dates,
  Tangency = cum_OOS,
  BuyHold  = cum_BH[1:length(cum_OOS)]
)

df.long <- pivot_longer(plot_df, cols=c("Tangency","BuyHold"),
                             names_to="Strategy", values_to="Cumulative_Wealth")

# Cumulative Out-of-Sample Performance
ggplot(df.long, aes(x=Date, y=Cumulative_Wealth, color=Strategy)) +
  geom_line(linewidth=0.8) +
  labs(title="",
       x="Date", y="Cumulative Wealth", color="Strategy") +
  scale_color_manual(values=c("blue","red")) +
  theme_minimal()
```

\newpage
# References

